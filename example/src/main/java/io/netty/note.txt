1.一个eventLoopGroup当中会包含一个或多个EventLoop
2.一个EventLoop在它的整个生命周期当中都只会与唯一一个Thread进行绑定
3.所有由EventLoop所处理的各种I/O事件都将在它所关联的那个Thread上进行处理
4.一个Channel在它的整个生命周期中只会注册在一个EventLoop上。
5.一个EventLoop在运行过程当中。会被分配给一个或者多个Channel。

重要结论：在netty中，channel的实现一定是线程安全的；基于此，我们可以存储一个channel的引用，并且在需要向远程端点发送数据时，通过这个引用来调用channel相应的方法；即便当时有很多线程都在使用它也不会出现多线程问题；而且，消息一定会按照顺序发送出去。


重要结论：我们在业务开发中，不要将长时间执行的耗时任务放入到eventLoop的执行队列中，因为它将会一直阻塞该线程所对应的所有channel上的其他执行任务，如果我们需要进行阻塞调用或是耗时的操作（实际开发中很常见），那么我们就需要使用一个专门的EventExecutor（业务线程池）。


通常会有两种实现方式

1.在 Channelhandler的回调方法中,使用自己定义的业务线程池,这样就可以实现异步调用。

2.借助于 Netty提供的向 ChannelPipeline添加 ChannelHandler时调用的 addLast方法来传递 EventExecutor。

说明:默认情况下(调用 addLast( handler), ChannelHandler中的回调方法都是由I/O线程所执行,如果调用了 ChannelPipeline addLast
( EventExecutorGroup group, ChannelHandler... handlers);方法,那么 Channelfandler中的回调方法就是由参数中的 group线程组来执行的。

